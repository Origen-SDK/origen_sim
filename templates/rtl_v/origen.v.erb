%#`include "<%= options[:top] %>"

`timescale 1ns/1ns

// 0 - Data
// 1 - Reserved 
//
// 0 - Drive
//
// 0 - Compare
//
// 0 - Force data 0
// 1 - Force data 1
//
// Parameter init_drive
// 0 - Initialize drive and assign to 0
// 1 - Initialize drive and assign to 1
// 2 - Don't initialize drive and assign to Z (default)
// -1 - Don't initialize drive or assign. Pin will be left unknown
module pin_driver(error, pin, sync);
  parameter init_drive = 2; // Which means don't drive initially, set to 0 or 1 to drive

  output reg error;
  inout pin;
  input sync;

  reg [1:0] data = 0;
  reg [1:0] force_data = 0;
  reg compare = 0;
  reg drive = 0;
  reg capture = 0;
  //reg [1023:0] memory = 0;
  reg [127:0] memory = 0;
  reg [127:0] memory_reversed = 0;
  reg [127:0] sync_memory = 0;

  wire drive_data = force_data[0] ? 0 : (force_data[1] ? 1 : data[0]);

  if (init_drive != -1) begin
    assign pin = drive ? drive_data : 1'bz;
  end

  // Debug signal to show the expected data in the waves
  wire expect_data = compare ? data[0] : 1'bz;

  always @(*) begin
    error = (compare && !capture) ? (pin == data[0] ? 0 : 1) : 0;
  end

  always @(posedge capture) begin
    if (sync == 1) begin
      sync_memory[127:1] <= sync_memory[126:0];
      sync_memory[0] <= pin;
    end else begin
      memory[127:1] <= memory[126:0];
      memory[0] <= pin;
      memory_reversed[126:0] <= memory_reversed[127:1];
      memory_reversed[127] <= pin;
    end
  end

  initial begin
    if (init_drive == 1) begin
      drive = 1;
      data[0] = 1;
    end else if (init_drive == 0) begin
      drive = 1;
      data[0] = 0;
    end
  end

endmodule

module pin_drivers(errors, <%= dut.rtl_pins.map { |n, p, o| "#{p.id}_o" }.join(', ') %>);

% dut.rtl_pins.each do |name, pin, options|
  output <%= pin.id %>_o;
% end

% dut.rtl_pins.each do |name, pin, options|
  wire <%= pin.id %>_err;
% end

  output reg [31:0] errors = 0;
  reg sync = 0;
  reg [31:0] match_errors = 0;
  reg match_loop = 0;

  always @(

% dut.rtl_pins.each_with_index do |(name, pin, options), i|
%   if i == 0
    posedge <%= pin.id %>_err
%   else
    or posedge <%= pin.id %>_err
%   end
% end
  ) begin
    if (match_loop == 1)
      match_errors[31:0] = match_errors[31:0] + 1;
    else
      errors[31:0] = errors[31:0] + 1;
  end

% dut.rtl_pins.each do |name, pin, options|
  pin_driver <%= pin.meta[:origen_sim_init_pin_state].nil? ? '' : "#(#{pin.meta[:origen_sim_init_pin_state]}) "%><%= pin.id %>(.pin(<%= pin.id %>_o), .error(<%= pin.id %>_err), .sync(sync));
% end


endmodule


// Placeholder for user notes. This will be an empty module if no notes were given
module user_notes;
% options[:user_notes].each do |name, note|
  parameter <%= name %> = "<%= note %>";
% end

endmodule


module debug(errors);
  parameter ORIGEN_SIM_VERSION = "<%= OrigenSim::VERSION %>";
  parameter COMPILATION_TIME_STAMP = "<%= Time.now %>";
  parameter COMPILATION_PATH = "<%= Dir.pwd %>";
  parameter DUT_NAME = "<%= options[:device_name] || 'No --device_name specified' %>";
  parameter SNAPSHOT_VERSION = "<%= options[:snapshot_version] || 'No --snapshot_version specified' %>";
  parameter PARENT_TB_VERSION = "<%= options[:parent_tb_version] || 'No --parent_tb_version specified' %>";
  
  input [31:0] errors;

  reg [1023:0] pattern = 0;
% OrigenSim::NUMBER_OF_COMMENT_LINES.times do |i|
  reg [1023:0] comments<%= i %> = 'h20;  // Contain a space by default
% end

  reg handshake;

  user_notes user_notes();
  
endmodule

module origen;

  reg finish = 0;

% dut.rtl_pins.each do |name, pin, options|
  wire <%= pin.id %>;
% end

  wire [31:0] errors;

  pin_drivers pins (
% dut.rtl_pins.each_with_index do |(name, pin, options), i|
    .<%= pin.id %>_o(<%= pin.id %>),
% end
    .errors(errors)
  );

  // Instantiate the DUT
  <%= options[:top].sub(/\..*/, '') %> dut (
% dut.power_pins.each do |name, pin, options|
    .<%= pin.id %>(<%= pin.id %>),
% end
% dut.ground_pins.each do |name, pin, options|
    .<%= pin.id %>(<%= pin.id %>),
% end
% # Keep track of the primary groups seen.
% seen_groups = []
% dut.rtl_pins.each_with_index do |(name, pin, options), i|
%   if options[:group]
%     unless seen_groups.include?(pin.primary_group)
    .<%= pin.primary_group.id %>({
%       pin.primary_group.each_with_index do |pin, i|
      <%= pin.id %><%= i == (pin.primary_group.size - 1) ? '' : ',' %>
%       end
    })<%= i == (dut.rtl_pins.size - 1) ? '' : ',' %>
%       seen_groups << pin.primary_group
%     end
%   else
    .<%= pin.rtl_name %>(<%= pin.id %>)<%= i == (dut.rtl_pins.size - 1) ? '' : ',' %>
%   end
% end
  );

  debug debug (
    .errors(errors)
  );

`ifdef ORIGEN_VCD 
  initial
  begin
    //$display("********************************");
    //$display("Creating origen.vcd...");
    //$display("********************************");
    //$dumpfile("origen.vcd");
    $dumpvars(0,origen);
  end
`endif

`ifdef ORIGEN_VPD 
  initial
  begin
    $vcdplusfile("origen.vpd");
    $vcdpluson;
    $vcdplusmemon;
  end
`endif

`ifdef ORIGEN_FSDB
  initial
  begin
    $fsdbDumpfile("origen.fsdb");
    $fsdbDumpvars(0, "+all");
  end
`endif


  always @(posedge finish) begin
    //$display("********************************");
    //$display("Finishing simulation...");
    //$display("********************************");
    $finish(2);
  end

%  Array(options[:incl]).each do |f|
  `include "<%= "#{f}" %>"
%  end

endmodule
