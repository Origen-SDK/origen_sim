![origen_sim](https://user-images.githubusercontent.com/158364/36662666-6b49d096-1adf-11e8-997e-889caba391b2.png)

origen_sim is an Origen plugin that enables semiconductor test patterns written in Origen/Ruby to be run in a dynamic Verilog simulation.

It provides a simulation tester driver which replaces the conventional Origen ATE tester drivers in order to pass requests to drive or expect pin values onto a simulator intead of rendering them to an ASCII file. Since the application-level Origen code is the same in both cases it guarantees that what happens in the simulation and in the final pattern are the same.

For debugging, origen_sim supports the injection of regular Ruby debugger breakpoints anywhere in the pattern source code. This will halt the simulation
at the given point in time and thereby allow it to be interatively debugged at the Ruby-source-code level.

For further documentation on how to use origen_sim and to learn about its capabilities, see the website: http://origen-sdk.org/sim

### How To Create a Simulation Object For Development of OrigenSim

From an OrigenSim workspace:

Select the environment you wish to use, e.g.:

~~~
origen e environment/cadence.rb
~~~

Run the following command to build a simulation object from [this example device](https://github.com/Origen-SDK/example_rtl/blob/master/dut1/dut1.v):

~~~
origen sim:build_example
~~~

Run a simulation to check that it is working:

~~~
origen g test
~~~

Repeat the above steps to recompile after making any changes to the VPI extension.


### Summary Of Operation

Here are some technical details on how origen_sim works, hopefully with enough detail to enable other engineers to contribute to its future development.

origen_sim provides components that can be compiled into a simulation object along with the design under test (DUT), a high level view of the process looks like this:

![image](https://user-images.githubusercontent.com/158364/28324051-6a149088-6bd2-11e7-936d-49ec87b2c0bb.png)

The main Origen Ruby process is invoked by generating a pattern as usual, e.g. <code>origen g my_pattern</code>, but with the environment setup to instantiate an instance of <code>OrigenSim::Tester</code> instead of say <code>OrigenTesters::V93K</code>.
The origen_sim tester will start off a Verilog process in parallel which will run a simulation on an object that has been created beforehand. This simulation object contains the DUT wrapped in an Origen testbench, and which has been compiled into a snapshot/object that also includes a [Verilog VPI](https://en.wikipedia.org/wiki/Verilog_Procedural_Interface) extension which provides a communication interface between Origen and the simulation world.

When the simulation process starts, the VPI extension immediately takes control and halts the simulator while it listens for further instructions from a Linux socket which was setup by origen_sim at the same time that the simulation was started.
As the Origen pattern generation process executes, the <code>OrigenSim::Tester</code> will translate any requests to drive or expect pin values, or to generate a cycle, into messages which are passed into the Linux socket. Upon receving these messages, the VPI process will manipulate the testbench's pin drivers to drive or read from the DUT and it will advance time by a cycle period every time a cycle is generated in the pattern.
The testbench to wrap and instantiate the DUT is generated by origen_sim and it provides a standard interface through which Origen can access any DUT.

In principle the DUT object can be any design that is wrapped by a conventional top-level RTL description. Meaning that origen_sim can be used to run digital simulations, or mixed-signal simulations on DUT objects that contain more complex analog modelling.

### The Testbench

The testbench is quite simple and it does little more than instantiate the DUT module and connects all of its pins to instances of [this pin driver module](https://github.com/Origen-SDK/origen_sim/blob/master/templates/rtl_v/origen.v.erb#L14).
The testbench module is named 'origen' and all origen_sim simulation dumps have this same top-level structure:

~~~
origen
     |--debug        # Contains an error count and other debug aids
     |--dut          # The DUT top-level
     |--pins         
           |--tdi    # Driver for the TDI pin (for example)
           |--tdo    # Driven for the TDO pin and so on
           |--tck
~~~



The driver contains a number of registers which are written to directly by the VPI process, allowing it to drive or expect a given data value (stored in <code>origen.pins.\<pin\>.data</code>) by writing a 1 to <code>origen.pins.\<pin\>.drive</code> or <code>origen.pins.\<pin\>.compare respectively</code>.
If the value being driven by the pin does match the expect data during a cycle, then an error signal will be asserted by the driver and this will increment an error counter that lives in <code>origen.debug.errors[31:0]</code>.

#### Supported Toolchains

##### Cadence

##### Generic

Generic toolchains allow you to use a tool that is not support out of the box by <code>OrigenSim</code>. For these, it is your responsiblity, using the <code>pre_run_start_block</code> and the
<code>post_run_start_block</code> to start the VPI process, but this allows for arbitrary commands to be run, with the context of the simulation, and allow end users to still use <code>origen g</code>
as if with a <code>OrigenSim</code> supported toolchain.

An example of such a setup could be:

~~~ruby
OrigenSim.generic do |sim|
  sim.startup_timeout 300
  sim.post_run_start do |s|
    # At this point, the socket is attempting to connect to the VPI
    # The below command will start up the VPI
    `path/to/custom/sim/script +socket+#{s.socket_id}`
  end
end
~~~


#### Configuring The Testbench

The testbench can be instantiated with configuration options.

### The VPI Extension

#### Configuring The VPI

### Register Syncing


